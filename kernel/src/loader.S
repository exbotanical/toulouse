.code32

.global _start

# This is the kernel entry-point.
# There's two ways we can end up here:
# 1. The bootloader implemented in boot/ loaded this code into memory, then
# jumped to it via a long jump; or
# 2. A different bootloader - such as GRUB - was used, in which case it will
# have jumped directly to this code.
# Effectively, both are doing the same thing. For #2, the host disk will
# copied just the kernel and not the full image with boot/ prepended.

# This allows us to support any bootloader that implements the multiboot spec.
# We're going to use multiboot 1 for now.

# Zero means we promise all loaded boot modules will be aligned on 4kb page boundaries.
.set ALIGNMENT,   1 << 0
# Says the bootloader should supply a memory map
.set MEMINFO,     1 << 1
# Flags basically provide metadata about our multiboot setup.
.set FLAGS,       ALIGNMENT | MEMINFO
# Yes, the magic work really must be this (or 0x2BADB002 if we're a bootloader).
.set MAGIC,       0x1BADB002
.set CHECKSUM,    -(MAGIC + FLAGS)

.section .multiboot_header, "a"
.align 4
.long    MAGIC
.long    FLAGS
.long    CHECKSUM

.section .bootstrap_stack, "aw", @nobits
.align 32
# Allocate an initial stack (amount is arbitrary - it just must be sufficient enough for initial use)
.skip 0x4000 # 16kb
stack_top:

.section .data

.align 0x1000
boot_page_table:
.set addr, 0
.rept 1024
.long addr | 1
.set addr, addr + 0x1000
.endr

.align 0x1000
boot_page_directory:
.rept 1024
.long (boot_page_table - 0xC0000000) + 1
.endr

.section .entry, "a"
.type _start, @function
_start:
	cli

	mov     $(boot_page_directory - 0xC0000000), %ecx
	mov     %ecx, %cr3

	mov     %cr0, %ecx
	or      $0x80000000, %ecx
	mov     %ecx, %cr0              # Enable paging. From this point onward, addresses are translated by the MMU.

	lea     start_kernel, %ecx      # Jump to higher half with an absolute jump.
	jmp     *%ecx

.section .text
.type start_kernel, @function
start_kernel:

	mov     $stack_top, %esp        # Set up the stack.
  push    %esi                    # Push the multi_boot info onto the stack
	call    kmain                   # Enter the high-level kernel

  jmp     .
