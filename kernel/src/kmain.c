#include "kmain.h"

#include "arch/cpu.h"
#include "arch/interrupt.h"
#include "arch/x86.h"
#include "drivers/console/tmpcon.h"
#include "drivers/dev/char/tty.h"
#include "drivers/dev/device.h"
#include "drivers/video/video.h"
#include "init/multiboot.h"
#include "interrupt/idt.h"
#include "interrupt/irq.h"
#include "interrupt/pic.h"
#include "interrupt/timer.h"
#include "kernel.h"
#include "kstat.h"
#include "mem/base.h"
#include "mem/paging.h"
#include "proc/process.h"

unsigned int real_last_addr;
kstat_t      kstat;

void
kmain (unsigned int magic, unsigned int mbi, unsigned int last_addr) {
  real_last_addr = last_addr - KERNEL_PAGE_OFFSET;
  // Maps the VGA memory device (0xB8000) to a console abstraction.
  // This allows us to print to the console before we've mapped any memory or
  // initialized pretty much all of the operating system now that the image has been
  // loaded into memory by the bootloader.
  vga_global_console_init();

  // Initializes multiboot data, passed to us via the bootloader following a spec (called
  // Multiboot). Effectively, multiboot spec data gives us the following:
  //
  //  Field                  Purpose
  //  ---------------------------------------------------------------------------
  //  mem_lower             - Size of memory below 1MB (in KB)
  //  mem_upper             - Size of memory above 1MB (in KB)
  //  mmap_addr             - Pointer to memory map (E820-style entries)
  //  mmap_length           - Length of the memory map
  //  boot_device           - BIOS boot device used to load the kernel
  //  cmdline               - Pointer to the kernel command line string
  //  mods_addr             - Address of loaded modules (e.g. initramfs)
  //  mods_count            - Number of loaded modules
  //  flags                 - Bitfield indicating which fields are valid
  //  drives_addr           - Address of BIOS drive info structure
  //  drives_length         - Length of drive info structure
  //  vbe_*                 - VESA BIOS Extensions (video mode info)
  //  framebuffer_*         - Framebuffer mode information for graphical output
  //  boot_loader_name      - Pointer to string with bootloader name
  //  apm_table             - Pointer to APM table (if available)
  //  acpi_table            - Pointer to RSDP/ACPI info table (if available)
  //
  // Note: The 'flags' field should always be checked to determine which fields
  // are actually valid before using them.
  multiboot_init(magic, mbi);
  klog_info("Multiboot data processed (if extant)");

  // Remap the PIC and mask all interrupts.
  // The Programmable Interrupt Controller (PIC) is a hardware device used in x86 systems to manage
  // interrupts from various devices (keyboard, timer, etc.). It ensures that when multiple devices
  // attempt to interrupt the CPU, the interrupts are handled properly in a controlled manner.
  // See local functions for more details and specifics.

  // Note: We might elect to use the more modern APIC later on.
  pic_init();
  klog_info("PIC remapped");

  // Allocate the IRQ table.
  // This is where we'll store interrupt handlers for various IRQs generated by hardware devices.
  // TODO: Rename bottom half to something more obvious
  irq_init();
  klog_info("IRQ table allocated");

  // Register interrupts and exception handlers.
  idt_init();
  klog_info("IDT initialized");

  // Allocate devices tables
  devices_init();
  klog_info("Devices table allocated");

  tty_init();
  klog_info("TTY table initialized");

  mem_init();
  klog_info("Permanent page tables installed");

  timer_init();
  klog_info("Timer initialized");

  video_init();
  klog_info("Video initialized");

  proc_init();
  klog_info("Process table initialized");

  int_enable();
  klog_info("Interrupts enabled");

  cpu_idle();
}
