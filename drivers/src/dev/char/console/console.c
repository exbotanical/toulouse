#include "drivers/dev/char/console/console.h"

#include "arch/interrupt.h"
#include "debug/logger.h"
#include "drivers/dev/char/console/csi.h"
#include "drivers/dev/char/console/sysconsole.h"
#include "drivers/dev/char/keyboard.h"
#include "drivers/dev/char/ps2.h"
#include "drivers/dev/char/tty/termbits.h"
#include "drivers/dev/char/tty/tty.h"
#include "drivers/dev/char/tty/vt.h"
#include "drivers/dev/char/vga.h"
#include "drivers/dev/char/video.h"
#include "drivers/dev/device.h"
#include "drivers/dev/kd.h"
#include "fs/ops.h"
#include "interrupt/timer.h"
#include "kconfig.h"
#include "lib/ctype.h"
#include "lib/printf.h"
#include "lib/string.h"
#include "mem/alloc.h"
#include "mem/page.h"

/* VT100 ID string generated by <ESC>Z or <ESC>[c */
#define VT100ID       "\033[?1;2c"

/* VT100 report status generated by <ESC>[5n */
#define DEVICE_OK     "\033[0n"
#define DEVICE_NOT_OK "\033[3n"

static vconsole_t consoles[NUM_VCONSOLES + 1];

short int  current_console;
short int* vconsole_screen[NUM_VCONSOLES + 1];
short int* vconsole_scrollback_history_buffer;

static fs_operations_t tty_driver_fs_ops = {
  .flags              = 0,
  .fsdev              = 0,
  // TODO:
  .open               = tty_open,
  .close              = tty_close,
  .read               = tty_read,
  .write              = tty_write,
  // .ioctl              = tty_ioctl,
  .llseek             = tty_llseek,
  .readdir            = NULL,
  .readdir64          = NULL,
  .mmap               = NULL,
  .select             = tty_select,
  .readlink           = NULL,
  .followlink         = NULL,
  .bmap               = NULL,
  .lookup             = NULL,
  .rmdir              = NULL,
  .link               = NULL,
  .unlink             = NULL,
  .symlink            = NULL,
  .mkdir              = NULL,
  .mknod              = NULL,
  .truncate           = NULL,
  .create             = NULL,
  .rename             = NULL,
  .read_block         = NULL,
  .write_block        = NULL,
  .read_inode         = NULL,
  .write_inode        = NULL,
  .ialloc             = NULL,
  .ifree              = NULL,
  .statfs             = NULL,
  .read_superblock    = NULL,
  .remount_fs         = NULL,
  .write_superblock   = NULL,
  .release_superblock = NULL,
};

static device_t tty_device = {
  .name              = "vconsole",
  .major             = VCONSOLE_MAJOR,
  .minors            = {0, 0, 0, 0, 0, 0, 0, 0},
  .minor_block_sizes = 0,
  .device_data       = NULL,
  .fs_ops            = &tty_driver_fs_ops,
  .requests_queue    = NULL,
  .xfer_data         = NULL,
  .next              = NULL,
};

static device_t console_device = {
  .name              = "console",
  .major             = SYSCON_MAJOR,
  .minors            = {0, 0, 0, 0, 0, 0, 0, 0},
  .minor_block_sizes = 0,
  .device_data       = NULL,
  .fs_ops            = &tty_driver_fs_ops,
  .requests_queue    = NULL,
  .xfer_data         = NULL,
  .next              = NULL,
};

static void
vconsole_buf_scroll_up (void) {
  // TODO: memcpy_w
  kmemcpy(
    vconsole_scrollback_history_buffer,
    vconsole_scrollback_history_buffer + video.columns,
    (VCONSOLE_BUF_SIZE - video.columns) * 2
  );
}

static void
vconsole_adjust (vconsole_t* vc, int x, int y) {
  if (x < 0) {
    x = 0;
  }
  if (x >= vc->columns) {
    x = vc->columns - 1;
  }
  if (y < 0) {
    y = 0;
  }
  if (y >= vc->rows) {
    y = vc->rows - 1;
  }
  vc->x = x;
  vc->y = y;
}

static void
insert_seq (struct tty* tty, char* buf, int count) {
  while (count--) {
    charq_put_char(&tty->read_q, *(buf++));
  }
  tty->input(tty);
}

static void
write_cr (vconsole_t* vc) {
  vc->x = 0;
}

static void
write_lf (vconsole_t* vc) {
  if (vc->y == vc->rows) {
    video.scroll_screen(vc, 0, CONS_SCROLL_UP);
  } else {
    vc->y++;
  }
}

static void
write_ri (vconsole_t* vc) {
  video.scroll_screen(vc, 0, CONS_SCROLL_DOWN);
}

static void
echo_char (vconsole_t* vc, unsigned char* buf, unsigned int count) {
  INTERRUPTS_OFF();

  if (vc->flags & CONSOLE_HAS_FOCUS) {
    if (video.buf_top) {
      video.restore_screen(vc);
      video.show_cursor(vc, CURSOR_MODE_ON);
      video.buf_top = 0;
    }
  }

  unsigned char ch;
  while (count--) {
    ch = *buf++;

    if (ch == '\0') {
      continue;
    } else if (ch == '\b') {
      if (vc->x) {
        vc->x--;
      }
    } else if (ch == '\a') {
      vconsole_beep();
    } else if (ch == '\r') {
      write_cr(vc);
    } else if (ch == '\n') {
      write_cr(vc);
      vc->y++;
      if (vc->flags & CONSOLE_HAS_FOCUS) {
        video.buf_y++;
      }
    } else if (ch == '\t') {
      while (vc->x < (vc->columns - 1)) {
        if (vc->tty->tab_stop[++vc->x]) {
          break;
        }
      }
      /* vc->x += TAB_SIZE - (vc->x % TAB_SIZE); */
      vc->check_x = 1;
    } else {
      if ((vc->x == vc->columns - 1) && vc->check_x) {
        vc->x = 0;
        vc->y++;
        if (vc->flags & CONSOLE_HAS_FOCUS) {
          video.buf_y++;
        }
      }

      if (vc->y >= vc->rows) {
        video.scroll_screen(vc, 0, CONS_SCROLL_UP);
        vc->y--;
      }

      video.put_char(vc, ch);

      if (vc->x < vc->columns - 1) {
        vc->check_x = 0;
        vc->x++;
      } else {
        vc->check_x = 1;
      }
    }

    if (vc->y >= vc->rows) {
      video.scroll_screen(vc, 0, CONS_SCROLL_UP);
      vc->y--;
    }

    if (vc->flags & CONSOLE_HAS_FOCUS) {
      if (video.buf_y >= VCONSOLE_BUF_LINES) {
        vconsole_buf_scroll_up();
        video.buf_y--;
      }
    }
  }

  video.update_cursor_pos(vc);

  INTERRUPTS_ON();
}

static bool
is_vconsole (unsigned short int dev) {
  return (DEVICE_MAJOR(dev) == VCONSOLE_MAJOR && DEVICE_MINOR(dev) <= NUM_VCONSOLES);
}

static void
set_default_color_attr (vconsole_t* vc) {
  vc->color_attr = DEFAULT_MODE;
  vc->bold       = 0;
  vc->underline  = 0;
  vc->blink      = 0;
  vc->reverse    = 0;
}

static void
init_vt_mode (vconsole_t* vc) {
  vc->vt_mode.mode   = VT_AUTO;
  vc->vt_mode.waitv  = 0;
  vc->vt_mode.relsig = 0;
  vc->vt_mode.acqsig = 0;
  vc->vt_mode.frsig  = 0;
  vc->vconsole_mode  = KD_TEXT;
  vc->tty->pid       = 0;
  vc->switch_tty     = -1;
}

static void
vconsole_start (tty_t* tty) {
  vconsole_t* vc = (vconsole_t*)tty->data;
  if (!vc->scrlock_on) {
    return;
  }

  vc->led_status &= ~LED_SCRLBIT;
  vc->scrlock_on  = false;
  ps2_set_leds(vc->led_status);
}

static void
vconsole_stop (tty_t* tty) {
  vconsole_t* vc = (vconsole_t*)tty->data;
  if (vc->scrlock_on) {
    return;
  }

  vc->led_status |= LED_SCRLBIT;
  vc->scrlock_on  = true;
  ps2_set_leds(vc->led_status);
}

static void
vconsole_delete_tab (tty_t* tty) {
  vconsole_t*   vc    = (vconsole_t*)tty->data;
  cblock_t*     cb    = tty->cooked_q.head;
  int           col   = 0;
  unsigned char count = 0;

  while (cb) {
    for (int i = 0; i < cb->next_write_index; i++) {
      if (i >= cb->next_read_index) {
        unsigned char ch = cb->data[i];
        if (ch == '\t') {
          while (!vc->tty->tab_stop[++col]);
        } else {
          col++;
          if (ISCTRL(ch) && !ISSPACE(ch) && tty->termios.c_lflag & ECHOCTL) {
            col++;
          }
        }
        col %= vc->columns;
      }
    }
    cb = cb->next;
  }

  count = vc->x - col;
  while (count--) {
    charq_put_char(&tty->write_q, '\b');
  }
}

static void
vconsole_reset (tty_t* tty) {
  vconsole_t* vc = (vconsole_t*)tty->data;

  vc->top        = 0;
  vc->rows       = video.rows;
  vc->columns    = video.columns;
  vc->check_x    = false;

  vc->led_status = 0;
  ps2_set_leds(vc->led_status);

  vc->scrlock_on = vc->numlock_on = vc->capslock_on = false;
  vc->has_esc = vc->has_bracket = vc->has_semicolon = vc->has_question = false;

  vc->tmp_storage_1 = vc->tmp_storage_2 = 0;
  vc->tmp_storage_num_entries           = 0;
  kmemset(vc->tmp_storage, 0, sizeof(vc->tmp_storage));

  set_default_color_attr(vc);
  vc->saved_x = vc->saved_y = 0;

  for (int n = 0; n < MAX_TAB_COLS; n++) {
    if (!(n % TAB_SIZE)) {
      vc->tty->tab_stop[n] = true;
    } else {
      vc->tty->tab_stop[n] = false;
    }
  }

  termios_reset(tty);
  vc->tty->win.ws_row    = vc->rows - vc->top;
  vc->tty->win.ws_col    = vc->columns;
  vc->tty->win.ws_xpixel = 0;
  vc->tty->win.ws_ypixel = 0;
  vc->tty->flags         = 0;

  init_vt_mode(vc);
  vc->flags &= ~CONSOLE_CLEARED;
  video.update_cursor_pos(vc);
}

static void
vconsole_write (tty_t* tty) {
  vconsole_t* vc = (vconsole_t*)tty->data;

  if (vc->flags & CONSOLE_HAS_FOCUS) {
    if (video.buf_top) {
      video.restore_screen(vc);
      video.buf_top = 0;
      video.show_cursor(vc, CURSOR_MODE_ON);
      video.update_cursor_pos(vc);
    }
  }

  unsigned char ch         = 0;
  bool          is_numeric = false;

  while (!vc->scrlock_on && tty->write_q.size > 0) {
    ch = charq_get_char(&tty->write_q);

    // Parse Control Sequence Introducer (CSI)
    if (vc->has_esc) {
      if (vc->has_bracket) {
        if (IS_NUMERIC(ch)) {
          is_numeric = true;

          if (vc->has_semicolon) {
            // Converts char digit to number
            vc->tmp_storage_2 *= 10;
            vc->tmp_storage_2 += ch - '0';
          } else {
            vc->tmp_storage_1 *= 10;
            vc->tmp_storage_1 += ch - '0';
          }

          vc->tmp_storage[vc->tmp_storage_num_entries] *= 10;
          vc->tmp_storage[vc->tmp_storage_num_entries] += ch - '0';
          continue;
        }

        switch (ch) {
          case ';': {
            vc->has_semicolon = true;
            vc->tmp_storage_2 = 0;
            vc->tmp_storage_num_entries++;
            continue;
          }

          case '?': {
            vc->has_question = true;
            continue;
          }

          /* Insert Character(s) <ESC>[ n @ */
          case '@': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? true : vc->tmp_storage_1;
            csi_at(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Up <ESC>[ n A */
          case 'A': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->x, vc->y - vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Down <ESC>[ n B */
          case 'B': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->x, vc->y + vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Forward <ESC>[ n C */
          case 'C': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->x + vc->tmp_storage_1, vc->y);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Backward <ESC>[ n D */
          case 'D': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->x - vc->tmp_storage_1, vc->y);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Next Line(s) <ESC>[ n E */
          case 'E': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, 0, vc->y + vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Previous Line(s) <ESC>[ n F */
          case 'F': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, 0, vc->y - vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Horizontal Position <ESC>[ n G */
          case 'G':
          case '`': {
            vc->tmp_storage_1 = vc->tmp_storage_1 ? vc->tmp_storage_1 - 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->tmp_storage_1, vc->y);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Home <ESC>[ ROW ; COLUMN H */
          case 'H':
          /* Horizontal Vertical Position <ESC>[ ROW ; COLUMN f */
          case 'f': {
            vc->tmp_storage_1 = vc->tmp_storage_1 ? vc->tmp_storage_1 - 1 : vc->tmp_storage_1;
            vc->tmp_storage_2 = vc->tmp_storage_2 ? vc->tmp_storage_2 - 1 : vc->tmp_storage_2;
            vconsole_adjust(vc, vc->tmp_storage_2, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Cursor Forward Tabulation <ESC>[ n I */
          case 'I': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            while (vc->tmp_storage_1--) {
              while (vc->x < (vc->columns - 1)) {
                if (vc->tty->tab_stop[++vc->x]) {
                  break;
                }
              }
            }

            vconsole_adjust(vc, vc->x, vc->y);
            vc->has_esc = false;
            continue;
          }

          /* Erase (Down/Up/Screen) <ESC>[J */
          case 'J':
            csi_J(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;

          /* Erase (End of/Start of/) Line <ESC>[K */
          case 'K': {
            csi_K(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Insert Line(s) <ESC>[ n L */
          case 'L': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            csi_L(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Delete Line(s) <ESC>[ n M */
          case 'M': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            csi_M(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Delete Character(s) <ESC>[ n P */
          case 'P': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            csi_P(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Scroll Up <ESC>[ n S */
          case 'S': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            while (vc->tmp_storage_1--) {
              video.scroll_screen(vc, 0, CONS_SCROLL_UP);
            }

            vc->has_esc = false;
            continue;
          }

          /* Scroll Down <ESC>[ n T */
          case 'T': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            while (vc->tmp_storage_1--) {
              video.scroll_screen(vc, 0, CONS_SCROLL_DOWN);
            }

            vc->has_esc = false;
            continue;
          }

          /* Erase Character(s) <ESC>[ n X */
          case 'X': {
            vc->tmp_storage_1 = !vc->tmp_storage_1 ? 1 : vc->tmp_storage_1;
            csi_X(vc, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          /* Query Device Code <ESC>[c */
          case 'c': {
            if (!is_numeric) {
              insert_seq(tty, VT100ID, 7);
            }

            vc->has_esc = false;
            continue;
          }

          /* Cursor Vertical Position <ESC>[ n d */
          case 'd': {
            vc->tmp_storage_1 = vc->tmp_storage_1 ? vc->tmp_storage_1 - 1 : vc->tmp_storage_1;
            vconsole_adjust(vc, vc->x, vc->tmp_storage_1);
            vc->has_esc = false;
            continue;
          }

          case 'g': {
            switch (vc->tmp_storage_1) {
              /* Clear Tab <ESC>[g */
              case 0: {
                vc->tty->tab_stop[vc->x] = 0;
                break;
              }

              /* Clear All Tabs <ESC>[3g */
              case 3:

              /* Clear All Tabs <ESC>[5g */
              case 5: {
                for (n = 0; n < MAX_TAB_COLS; n++) {
                  vc->tty->tab_stop[n] = 0;
                }
                break;
              }
            }

            vc->has_esc = false;
            continue;
          }

          case 'h': {
            if (vc->has_question) {
              switch (vc->tmp_storage_1) {
                /* Switch Cursor Visible <ESC>[?25h */
                case 25: {
                  video.show_cursor(vc, CURSOR_MODE_ON);
                  break;
                }
              }
            }

            vc->has_esc = false;
            continue;
          }

          case 'l': {
            if (vc->has_question) {
              switch (vc->tmp_storage_1) {
                /* Switch Cursor Invisible <ESC>[?25l */
                case 25: {
                  video.show_cursor(vc, CURSOR_MODE_OFF);
                  break;
                }
              }
            }

            vc->has_esc = false;
            continue;
          }

          /* Select Graphic Rendition <ESC> n ... m */
          case 'm': {
            vc->tmp_storage_num_entries++;
            csi_m(vc);
            vc->has_esc = false;
            continue;
          }

          case 'n': {
            if (!vc->has_question) {
              switch (vc->tmp_storage_1) {
                /* Query Device Status <ESC>[5n */
                case 5: {
                  insert_seq(tty, DEVICE_OK, 4);
                  break;
                }

                /* Query Cursor Position <ESC>[6n */
                case 6: {
                  char cursor_pos[8];
                  int  len = sprintf(cursor_pos, "\033[%d;%dR", vc->y, vc->x);
                  insert_seq(tty, cursor_pos, len);
                  break;
                }
              }
            }

            vc->has_esc = false;
            continue;
          }

          /* Top and Bottom Margins <ESC>[r  / <ESC>[{start};{end}r */
          case 'r': {
            if (!vc->tmp_storage_1) {
              vc->tmp_storage_1++;
            }

            if (!vc->tmp_storage_2) {
              vc->tmp_storage_2 = video.rows;
            }

            if (vc->tmp_storage_1 < vc->tmp_storage_2 && vc->tmp_storage_2 <= video.rows) {
              vc->top  = vc->tmp_storage_1 - 1;
              vc->rows = vc->tmp_storage_2;
              vconsole_adjust(vc, 0, 0);
            }

            vc->has_esc = false;
            continue;
          }

          /* Save Cursor <ESC>[s */
          case 's': {
            vc->saved_x = vc->x;
            vc->saved_y = vc->y;
            vc->has_esc = false;
            continue;
          }

          /* Restore Cursor <ESC>[u */
          case 'u': {
            vc->x       = vc->saved_x;
            vc->y       = vc->saved_y;
            vc->has_esc = false;
            continue;
          }

          default: {
            vc->has_esc = false;
            break;
          }
        }

      } else {
        switch (ch) {
          case '[': {
            vc->has_bracket   = true;
            vc->has_semicolon = false;
            vc->has_question  = false;
            vc->tmp_storage_1 = vc->tmp_storage_2 = 0;
            vc->tmp_storage_num_entries           = 0;
            kmemset(vc->tmp_storage, 0, sizeof(vc->tmp_storage));
            continue;
          }

          /* Save Cursor & Attrs <ESC>7 */
          case '7': {
            vc->saved_x = vc->x;
            vc->saved_y = vc->y;
            vc->has_esc = false;
            continue;
          }

          /* Restore Cursor & Attrs <ESC>8 */
          case '8': {
            vc->x       = vc->saved_x;
            vc->y       = vc->saved_y;
            vc->has_esc = false;
            continue;
          }

          /* Scroll Up <ESC>D */
          case 'D': {
            write_lf(vc);
            vc->has_esc = false;
            continue;
          }

          /* Move To Next Line <ESC>E */
          case 'E': {
            write_cr(vc);
            write_lf(vc);
            vc->has_esc = false;
            continue;
          }

          /* Set Tab <ESC>H */
          case 'H': {
            vc->tty->tab_stop[vc->x] = 1;
            vc->has_esc              = false;
            continue;
          }

          /* Scroll Down <ESC>M */
          case 'M': {
            write_ri(vc);
            vc->has_esc = false;
            continue;
          }

          /* Identify Terminal <ESC>Z */
          case 'Z': {
            insert_seq(tty, VT100ID, 7);
            vc->has_esc = false;
            continue;
          }

          /* Reset Device <ESC>c */
          case 'c': {
            vconsole_reset(vc->tty);
            vc->x = vc->y = 0;
            csi_J(vc, CSI_J_SCREEN);
            vc->has_esc = false;
            continue;
          }

          default: {
            vc->has_esc = false;
            break;
          }
        }
      }
    }

    switch (ch) {
      case '\033': {
        vc->has_esc       = true;
        vc->has_bracket   = false;
        vc->has_semicolon = false;
        vc->has_question  = false;
        vc->tmp_storage_1 = vc->tmp_storage_2 = 0;
        continue;
      }

      default: {
        echo_char(vc, &ch, 1);
        continue;
      }
    }
  }

  if (ch) {
    if (vc->vconsole_mode != KD_GRAPHICS) {
      video.update_cursor_pos(vc);
    }
    wakeup(&tty_write);
  }
}

void
vconsole_select (int new_cons) {
  new_cons++;
  if (new_cons > NUM_VCONSOLES) {
    // TODO: log
    return;
  }

  if (current_console != new_cons) {
    vconsole_t this_console = consoles[current_console];

    if (this_console.vt_mode.mode == VT_PROCESS) {
      if (!sig_kill_pid(this_console.tty->pid, this_console.vt_mode.acqsig, SIGSENDER_KERNEL)) {
        this_console.switch_tty = new_cons;
        return;
      }

      init_vt_mode(&this_console);
    }

    if (this_console.vc_mode == KD_GRAPHICS) {
      return;
    }

    vconsole_select_final(new_cons);
  }
}

void
vconsole_select_final (int new_cons) {
  if (current_console != new_cons) {
    vconsole_t new     = consoles[new_cons];
    vconsole_t current = consoles[current_console];

    if (new.vt_mode.mode == VT_PROCESS) {
      if (sig_kill_pid(new.tty->pid, new.vt_mode.acqsig, SIGSENDER_KERNEL)) {
        init_vt_mode(&new);
      }
    }

    if (video.buf_top) {
      video.buf_top = 0;
      video.show_cursor(&current, CURSOR_MODE_ON);
      video.update_curpos(&current);
    }

    current.vidmem   = NULL;
    current.flags   &= ~CONSOLE_HAS_FOCUS;

    new.vidmem       = (unsigned char*)video.address;
    new.flags       |= CONSOLE_HAS_FOCUS;

    current_console  = new_cons;

    video.update_curpos(&current);
    video.restore_screen(&current);

    ps2_set_leds(current.led_status);

    video.buf_y   = current.y;
    video.buf_top = 0;

    // TODO: word size
    kmemset(vconsole_scrollback_history_buffer, CLEAR_MEM, VCONSOLE_BUF_SIZE);
    kmemcpy(vconsole_scrollback_history_buffer, (short int*)vc->screen, CONSOLE_SIZE);

    video.show_cursor(&current, CURSOR_MODE_COND);
    video.cursor_blink((unsigned int)&current);
  }
}

void
vconsole_unclear_screen (vconsole_t* vc) {
  if (!(vc->flags & CONSOLE_CLEARED)) {
    return;
  }

  video.restore_screen(vc);
  vc->flags &= ~CONSOLE_CLEARED;
  video.show_cursor(vc, CURSOR_MODE_ON);
}

void
vconsole_beep (void) {
  // TODO:
  // timer_task_request_t trq;

  // pit_beep_on();
  // trq.fn  = pit_beep_off;
  // trq.arg = 0;
  // timer_task_add(&trq, HZ / 8);
}

void
console_init (void) {
  for (int num = 1; num <= NUM_VCONSOLES; num++) {
    deviceno_t devnum = DEVICE_MKDEV(VCONSOLE_MAJOR, num);

    if (tty_register(devnum) == RET_OK) {
      tty_t* tty              = tty_get(devnum);
      tty->data               = (void*)&consoles[num];

      tty->stop               = vconsole_stop;
      tty->start              = vconsole_start;
      tty->delete_tab         = vconsole_delete_tab;
      tty->reset              = vconsole_reset;
      tty->input              = tty_cook_input;
      tty->output             = vconsole_write;

      vconsole_t this_console = consoles[num];

      this_console.tty        = tty;

      if (video_using_vga()) {
        this_console.back_buffer = (short int*)kmalloc(PAGE_SIZE);
      }
      if (video_using_vesa_framebuffer()) {
        this_console.back_buffer = vconsole_screen[num];
      }

      this_console.main_buffer = NULL;
      kmemset(this_console.back_buffer, CLEAR_MEM, CONSOLE_SIZE);
      vconsole_reset(tty);
    }
  }

  current_console         = 1;

  vconsole_t this_console = consoles[current_console];

  video.show_cursor(&this_console, CURSOR_MODE_ON);
  this_console.main_buffer  = (unsigned char*)video.address;
  this_console.flags       |= CONSOLE_HAS_FOCUS;

  if (video_using_vga()) {
    kmemcpy(this_console.main_buffer, video.address, CONSOLE_SIZE);
  }

  video.get_cursor_pos(&this_console);
  video.update_cursor_pos(&this_console);
  video.buf_y   = this_console.y;
  video.buf_top = 0;

  DEVICE_SET_MINOR(console_device.minors, 0);
  DEVICE_SET_MINOR(console_device.minors, 1);

  for (unsigned int n = 0; n < NUM_VCONSOLES; n++) {
    DEVICE_SET_MINOR(tty_device.minors, n);
  }

  device_register(DEVTYPE_CHAR, &console_device);
  device_register(DEVTYPE_CHAR, &tty_device);

  tty_t* tty;

  unsigned int syscon = 0;
  // TODO: consistent iter var name
  for (unsigned int i = 0; i < NUM_SYSCONSOLES; i++) {
    if (is_vconsole(sysconsole_table[i].dev) && (tty = tty_get(sysconsole_table[i].dev))) {
      if (!syscon) {
        syscon = tty->devnum;
      }

      sysconsole_register(tty);
    }
  }

  if (syscon) {
    tty = tty_get(syscon);
    flush_log_buf(tty);
  }
}
